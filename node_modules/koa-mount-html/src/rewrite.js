const debug = require('debug')('koa-mount');
const compose = require('koa-compose');

const path = require('path');
const url = require('url');

const CONTENT_TYPE_HTML = 'text/html';

// function* rewriteIndex(next) {
//   if (this.accepts().toString().substr(0, CONTENT_TYPE_HTML.length) === CONTENT_TYPE_HTML) {
//     this.request.url = '/index.html';
//   }
//   yield *next;
// }


function evaluateRewriteRule(parsedUrl, match, rule) {
  if (typeof rule === 'string') {
    return rule;
  }
  else if (typeof rule !== 'function') {
    throw new Error('Rewrite rule can only be of type string of function.');
  }

  return rule({
    parsedUrl: parsedUrl,
    match: match
  });
}

function acceptsHtml(header) {
  return header.indexOf('text/html') !== -1 || header.indexOf('*/*') !== -1;
}

// function getLogger(options) {
//   if (options && options.logger) {
//     return options.logger;
//   }
//   else if (options && options.verbose) {
//     return console.log.bind(console);
//   }
//   return () => {};
// }

exports = module.exports = function mountHtmlGet(options, app) {
  // const app = _app ? _app : _options;
  // const options = _app ? _options : {};
  // const logger = getLogger(options);

  // compose
  const downstream = app && app.middleware
    ? compose(app.middleware)
    : app;

  // return function(req, res, next) {
  return function* (upstream) {
    // var headers = req.headers;
    const accepts = this.accepts().toString();
    const originalUrl = this.request.url;
    var rewriteTarget = options.index || '/index.html';
    var parsedUrl;
    var rewritten;

    if (this.request.method === 'GET'
        && accepts && typeof accepts === 'string'
        && accepts.indexOf('application/json') !== 0
        && acceptsHtml(accepts)) {

      parsedUrl = url.parse(this.request.url);

      if (options.rewrites) {
        options.rewrites.some(rewrite => {
          const match = parsedUrl.pathname.match(rewrite.from);

          if (match !== null) {
            rewriteTarget = evaluateRewriteRule(parsedUrl, match, rewrite.to);
            return true;
          }
        });
      }

      if (rewriteTarget || parsedUrl.pathname.indexOf('.') === -1) {

        this.path = rewriteTarget || '/';

        if (downstream) {
          yield* downstream.call(this, function * callback(){
            yield* upstream;
          }.call(this));
        }
        else {
          this.request.url = rewriteTarget;
          yield* upstream;
        }
      }

    }

    yield *upstream;
  };
};
